# Gembah-Package-Cp-Invention-2025-HaloBeam-Ip.-Protections-enforced
# HaloBeam™ Investor Deck —By: Christopher Perry 2025
---
1. Introduction
HaloBeam™ — DreamStation The smart bedside device that uses light, sound, and design to improve sleep, focus, and wellness.

![1000022124](https://github.com/user-attachments/assets/1babace9-a98f-4624-84b0-32f4615b023e)


<img width="1024" height="1024" alt="1000022082" src="https://github.com/user-attachments/assets/edf24b54-cf07-4a19-bbdd-f700c52c9498" />

<img width="1024" height="1536" alt="1000022115" src="https://github.com/user-attachments/assets/beab3be1-f314-4ab0-b4f3-ecc6b5e20059" />


---


<video src="https://github.com/user-attachments/assets/cf1625de-2984-45a3-ad30-138a6c2b9034" controls width="720">
  Your browser does not support the video tag.
</video>




https://github.com/user-attachments/assets/d125eaae-9a3f-4ec7-b479-a2b31a85cff2




https://github.com/user-attachments/assets/7ee6470a-f0c7-4199-9eaa-a04048b0da03





---

2. 🛑 The Problem

Text:

Nightstands today are cluttered with too many devices: lamp, alarm clock, speaker, charging pad.

This device fragmentation leads to ugly, confusing, and ineffective user experiences.

Loud alarms shock us awake, and generic smart speakers don’t solve real physiological needs.


Visual: <img width="1536" height="1024" alt="1000022076" src="https://github.com/user-attachments/assets/8d30af6e-8e3a-483a-ac56-45cfb35c7040" />

![1000022111](https://github.com/user-attachments/assets/83de015f-6cbe-4cc7-ae06-0dcf43762b4a)



---

3. 🌟 The Solution: HaloBeam™

Text:
A single, elegant device that integrates light, sound, and charging.
Seamless, wellness-driven, beautiful design.

Visual: <img width="832" height="1248" alt="1000022009" src="https://github.com/user-attachments/assets/d82d636d-1cd0-414e-81bc-4fa7951d6b87" />



https://github.com/user-attachments/assets/b3c64b34-7d12-49d5-a19d-24bbf6986d5f


---

4. 🎯 Core Value Proposition

Text:

Sleep Better. Gentle sunrise projection aligned to circadian rhythms.

Focus Better. Crisp, cool light enhances productivity.

Live Better. Transform rooms with immersive ambient scenes like auroras or stars.
All from one premium bedside hub.


Visual: Triptych —
Left: Warm Wake (amber sunrise).

![1000022011](https://github.com/user-attachments/assets/aafc521d-70ff-4bbf-b4de-2bbefd17b37f)

<img width="832" height="1248" alt="1000022009" src="https://github.com/user-attachments/assets/61e52f9f-c48f-4156-9760-7d787c4bb348" />


Middle: Focus Cool (white-blue).
<img width="1536" height="1024" alt="1000022083" src="https://github.com/user-attachments/assets/03264741-1e83-4593-bafc-38c345c457ce" />

<img width="1536" height="1024" alt="1000022075" src="https://github.com/user-attachments/assets/8c8b7b16-c2e6-4c21-86ca-4044988643d3" />


---



<video src="https://github.com/user-attachments/assets/51d12d58-103b-4c42-b9dc-c52172ffa7b1" controls width="720">
  Your browser does not support the video tag.
</video>



---



---

5. 🧩 Features

User-Facing

Qi2 Wireless Charging (15W).

360° DFOP-Lite Speaker.

Modular Light Projection (swappable caps).


Under the Hood

ESP32-S3 MCU.

BLE + sensors for safety and interactivity.

OTA firmware for new features.


Visual: core.<img width="1024" height="1536" alt="1000022112" src="https://github.com/user-attachments/assets/26ba2ea5-ade7-47b3-9d40-17247b1c81a0" />

![1000022117](https://github.com/user-attachments/assets/d78b47b1-eed6-4ef0-a004-6e5a64f5b838)



---

6. 🎬 Product Demo — Scenes

Each slide = one core mode.

6.1 Warm Wake
Light-based alarm for gentle wake-up.
Visual: Ceiling sunrise gradient, HaloBeam glowing amber.

6.2 Focus Cool
White-blue crisp light for concentration.
Visual: HaloBeam facing user, phone on Qi2 pad, ceiling projection steady.

6.3 Sleep Amber
Candle-like glow for bedtime.
Visual: Dim bedroom, soft amber ring.

6.4 Aurora Flow
Dynamic ribbons for relaxation.
Visual: HaloBeam projecting blue/green auroras.

6.5 Starry Night (optional)
Twinkling starfield projection.
Visual: Indigo ceiling, white/blue stars, subtle pulsing halo.


---

7. 🌍 Market Opportunity

Text:
HaloBeam intersects three multi-billion-dollar markets.

Sleep Tech ($60B+ by 2030)

Smart Home ($150B+ by 2030)

Wellness Tech (double-digit CAGR)


Visual: <img width="1536" height="1024" alt="1000022088" src="https://github.com/user-attachments/assets/32c98119-53c1-472f-8ef9-4a5797f1b460" />

<img width="1536" height="1024" alt="1000022086" src="https://github.com/user-attachments/assets/52c2170e-e57c-4194-ab61-154da6bb26bd" />



---

8. 🛒 Go-to-Market

Phase 1: Kickstarter — validate, community, first funding.
Phase 2: D2C e-commerce — leverage brand + community.
Phase 3: Retail & global scaling.

Visual: 3-step LEGO-style path diagram.


---

9. 💰 Business Model

Text:
COGS ≈ $120
MSRP = $349
Gross Margin ≈ 65%

Upsell: subscription scenes, extra projection caps.

Visual: Bar chart — ![1000022119](https://github.com/user-attachments/assets/7247224b-bdce-4362-83b6-8edf6a0e0a27)



---

10. 👥 Team

Christopher Perry — Inventor & Visionary.
Future hires: advisors + go-to-market experts.

Visual: ![1000022132](https://github.com/user-attachments/assets/9e89187d-0b7c-4ec0-b30d-8d1c8ef2b2e3)


---

11. 📦 Appendix

Technical deep dives (wiring, firmware tree).

Scene briefs (Warm Wake, Focus Cool, Aurora, Starry).

Extended market research.

IP roadmap (patents pending).




---


![1000022120](https://github.com/user-attachments/assets/05a28158-5eb5-45d6-8b60-5be675bd9992)


# Cp Inventions 2025 HaloBeam™ Firmware v1.2
![1000020982](https://github.com/user-attachments/assets/b9268154-d081-4e7e-b620-e0911530c1a5)

<img width="1024" height="1536" alt="1000020987" src="https://github.com/user-attachments/assets/f124245c-7eaa-4321-a53d-fb7ddb4b5f0e" />

![1000020984](https://github.com/user-attachments/assets/aa0bf707-2995-43c9-85e7-4bee2735e1aa)

Manufacturing-ready firmware for the HaloBeam bedside device, built for ESP32-S3 using ESP-IDF 5.x. Integrates **Qi2 wireless charging**, **360° DFOP-Lite speaker**, **modular projection** (stars, auroras, glyphs/info), and a **36-pixel LED ring**. Designed for privacy (no mic), BLE control, HTTPS OTA updates, and robust safety.

**Repository**: [Cp-Invention-2025-Halo-Beam](https://github.com/ne3xtg3n/Cp-Invention-2025-Halo-Beam-)  
**Version**: 1.2 (Manufacturing Ready – ESP32-S3)  
**Status**: Patent Pending  
**Inventor**: Christopher Perry

## Features
- **Qi2 Charging**: 15–30 W with FOD and ISR-based status.
- **Audio**: I2S-driven 2× 40 mm speakers + passive radiator (MAX98357A); scene-based tones.
- **Projection**: PWM-controlled LED (2–5 W); modular caps (Starry, Aurora, Glyphs/Info).
- **LED Ring**: 36 WS2812B pixels; scenes (Warm Wake, Focus Cool, Sleep Amber, Aurora, Starry).
- **Sensors**: IMU (ICM-42670) for tilt-based brightness, NTC thermistor, battery ADC.
- **Control**: BLE GATT for scene/brightness/time setting/Wi-Fi creds; crown button for pairing/factory test.
- **Safety**: Thermal derate (>55 °C), cutoff (≥65 °C); battery protection (<3.4 V).
- **OTA**: HTTPS firmware updates with BLE-provisioned WiFi.

## Build Instructions
```bash
# Install ESP-IDF 5.x
export IDF_PATH=~/esp-idf
source $IDF_PATH/export.sh

# Clone and build
git clone https://github.com/ne3xtg3n/Cp-Invention-2025-Halo-Beam-.git
cd Cp-Invention-2025-Halo-Beam-
idf.py set-target esp32s3
idf.py build
idf.py -p /dev/ttyUSB0 flash monitor

# OTA setup
# 1. Place server_root_cert.pem in components/ota
# 2. Set OTA_SERVER_URL in main/config.h (e.g., https://firmware.your-company.com/halobeam-v1.2.bin)
# 3. Provision WiFi via BLE (SSID/PW) or hardcoded NVS

# Factory test
# Hold crown button (GPIO0) during boot
```


---


+-------------------+       +----------------------------+
|   Phone (Qi2)     |<--15W-30W--> Qi2 PMIC + Coil      |
+-------------------+       +-------------+--------------+
                                     IRQ GPIO10  EN GPIO11
                                          \      /
+---------------------------------------------------------+
|                HaloBeam Core (ESP32-S3)                 |
|  I2C IMU (ICM-42670)  -> SDA GPIO8 / SCL GPIO9          |
|  LED Ring (WS2812B)   -> RMT DATA GPIO18                |
|  Projector LED PWM    -> LEDC ch0 GPIO4                 |
|  Servo (optional)     -> GPIO5                          |
|  Button (crown)       -> GPIO0 (pull-up, debounced)     |
|  ADC Batt / NTC       -> GPIO2 / GPIO3                  |
|  I2S Audio (MAX98357) -> BCLK15 / WS16 / DATA17         |
|  BLE GATT + HTTPS OTA -> Wi-Fi/BLE stack                |
+---------------------------------------------------------+


---

Technical Specs

Projection: 1–2 m upward; modes: Starry / Aurora / Glyphs

LED Ring: 36 px @ 800 kHz; scenes: Warm Wake / Focus Cool / Sleep Amber / Aurora / Starry

Audio: I2S-driven tones for bring-up; WAV/stream ready path

Charging: Qi2 15–30 W (module-dependent); FOD passthrough

Thermal: Derate > 55 °C; cutoff ≥ 65 °C

Compliance targets: FCC/CE/UKCA; RoHS; Qi2; DOE VI PSU

Privacy: No microphone; physical pairing action



---

External I/O & Pinout (Rev-B)

Function	Pin	Notes

LED Ring (WS2812B)	GPIO18	RMT TX
Projector PWM	GPIO4	LEDC ch0, 1.2 kHz, 12-bit
Servo (optional)	GPIO5	SG90-class
Crown Button	GPIO0	Pull-up; tap/long-press
Qi2 Enable	GPIO11	Drive HIGH to enable
Qi2 Interrupt	GPIO10	Active-low IRQ
IMU Interrupt	GPIO12	Future wake
I²C SDA / SCL	GPIO8 / GPIO9	400 kHz
ADC Battery / NTC	GPIO2 / GPIO3	ADC1_CH1 / ADC1_CH2
I2S BCLK / WS / SD	GPIO15 / GPIO16 / GPIO17	MAX98357A



---

Harness & Wiring

[USB-C 24 W PSU] ──> [DC 5V BUS] ──┬── MAX98357A (VDD)
                                   ├── LED Ring 5V
                                   ├── Projector LED Driver (5V)
                                   └── Qi2 PMIC (5V)

Qi2 PMIC:
  EN  ───── GPIO11
  IRQ ───── GPIO10 (active-low)
  SDA/SCL ─ (optional) I²C0 (GPIO8/9)

LED Ring:
  DATA ─── GPIO18 (series 330–470 Ω recommended)
  5V/GND ─ decouple with 1000 µF near ring

IMU ICM-42670:
  SDA/SCL ─ GPIO8/9
  INT     ─ GPIO12 (optional)
  3V3/GND

Projector LED:
  PWM ──── GPIO4 (to LED driver DIM)
  5V/GND  ─ driver supply

Layout notes

Star ground at power entry; keep LED ring return separate to reduce audio noise.

Add TVS at USB-C 5V; ferrite beads on speaker/Qi harness for EMC.

Keep WS2812B data trace short (<15 cm) and series-resisted.



---


Build Instructions

# ESP-IDF 5.x
export IDF_PATH=~/esp-idf
source $IDF_PATH/export.sh

git clone https://github.com/your-repo/halobeam-firmware-v1.2.git
cd halobeam-firmware-v1.2
idf.py set-target esp32s3
idf.py build
idf.py -p /dev/ttyUSB0 flash monitor

# OTA
# 1) Place server_root_cert.pem in components/ota
# 2) Set OTA_SERVER_URL in main/config.h
# 3) Provision Wi-Fi via BLE (CHAR_WIFI) or pre-load NVS

Factory test: hold crown (GPIO0) during boot.


---

## Repository Structure

- Cp-Invention-2025-Halo-Beam-
  - README.md                ← Project overview & setup
  - LICENSE                  ← License file
  - CMakeLists.txt           ← Top-level CMake config
  - partitions.csv           ← Partition table definition
  - sdkconfig.defaults       ← Default ESP-IDF config

  - main/
    - CMakeLists.txt         ← Component build file
    - config.h               ← Hardware/scene configuration
    - main.c                 ← Main application logic

  - components/
    - hal/                   ← LEDs, IMU, Qi2, I2S, OLED
    - power/                 ← Battery & thermal management
    - pid/                   ← PID control loop
    - ble/                   ← BLE GATT server
    - safety/                ← Guards & watchdogs
    - nvs_config/            ← Wi-Fi credential storage
    - input/                 ← Button & gestures
    - logging/               ← Fault/buffer logging
    - state/                 ← Scene & factory test state
    - telemetry/             ← Diagnostics & hooks
    - ota/                   ← HTTPS OTA update

  - docs/
    - BOM.md
    - Power_Budget.md
    - Thermal_Policy.md
    - Compliance_Test_Plan.md
    - Factory_Test_SOP.md
    - BLE_Protocol.md
    - OTA_Hosting_Guide.md
    - EMC_ESD_Checklist.md
    - Mechanical_Notes.md
    - img/                   ← Diagrams, renders, photos

  - scripts/
    - flash.sh               ← Flash helper
    - size.sh                ← Firmware size report

  - .github/
    - workflows/
      - build.yml            ← CI build workflow

---

Source Code (Full)

> All code below is buildable, production-ready for ESP-IDF 5.x.
Copy each block into the matching path.



Root

<details><summary><code>CMakeLists.txt</code></summary>cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(halobeam)

</details><details><summary><code>partitions.csv</code></summary># Name,   Type, SubType, Offset,  Size,   Flags
nvs,      data, nvs,     0x9000,  0x6000,
otadata,  data, ota,     0xF000,  0x2000,
phy_init, data, phy,     0x11000, 0x1000,
ota_0,    app,  ota_0,   0x12000, 0x170000,
ota_1,    app,  ota_1,   0x182000,0x170000,

</details><details><summary><code>sdkconfig.defaults</code></summary>CONFIG_FREERTOS_UNICORE=n
CONFIG_ESP_CONSOLE_UART_DEFAULT=y
CONFIG_BT_BLUEDROID_ENABLED=y
CONFIG_BT_NIMBLE_ENABLED=n
CONFIG_BT_BLE_42_FEATURES_SUPPORTED=y
CONFIG_BT_BLE_50_FEATURES_SUPPORTED=y
CONFIG_ESP_WIFI_ENABLED=y
CONFIG_ESP_WIFI_SOFTAP_SUPPORT=n
CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_CUSTOM_APP_BIN_OFFSET=0x12000
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_TIMEOUT_S=5
CONFIG_I2S_ENABLED=y
CONFIG_ADC_ENABLED=y

</details>
---

main/

<details><summary><code>main/CMakeLists.txt</code></summary>idf_component_register(SRCS "main.c"
                      INCLUDE_DIRS "."
                      PRIV_REQUIRES hal pid ble safety power nvs_config input logging state telemetry ota audio)

</details><details><summary><code>main/config.h</code></summary>#pragma once
include "sdkconfig.h"
include <stdint.h>

/* ==== Hardware mapping (revA) ==== */
define GPIO_LED_RING_DATA    18
define LED_RING_COUNT        36

define GPIO_PROJ_PWM         4
define PROJ_PWM_CHANNEL      0
define PROJ_PWM_FREQ_HZ      1200
define PROJ_PWM_RES_BITS     12

define GPIO_DIFFUSER_SERVO   5

define I2C_SCL_PIN           9
define I2C_SDA_PIN           8
define I2C_PORT_NUM          0
define I2C_FREQ_HZ           400000

define GPIO_QI2_INT          10
define GPIO_QI2_EN           11

define GPIO_TILT_INT         12
define GPIO_BUTTON           0

define ADC_BATT_CH           1
define NTC_ADC_CH            2

/* ==== PID defaults ==== */
define PID_KP  0.85f
define PID_KI  0.10f
define PID_KD  0.02f
define PID_DT_SEC 0.05f

/* ==== Thermal thresholds (degC) ==== */
define T_WARN_C   55.0f
define T_LIMIT_C  65.0f

/* ==== Battery thresholds (V) ==== */
define VBATT_LOW_V   3.55f
define VBATT_CRIT_V  3.40f

/* ==== BLE ==== */
define BLE_DEVICE_NAME "HaloBeam"

/* ==== OTA ==== */
define OTA_SERVER_URL "https://firmware.your-company.com/halobeam-v1.2.bin"

/* ==== Scenes ==== */
typedef enum {
  SCENE_WARM_WAKE=0, SCENE_FOCUS_COOL, SCENE_SLEEP_AMBER, SCENE_AURORA, SCENE_STARRY
} scene_t;

</details><details><summary><code>main/main.c</code></summary>#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "config.h"
#include "hal.h"
#include "led_driver.h"
#include "tilt_sensor.h"
#include "coil_driver.h"
#include "battery_monitor.h"
#include "thermal_monitor.h"
#include "pid_control.h"
#include "ble_gatt_server.h"
#include "safety_manager.h"
#include "nvs_config.h"
#include "gesture_sensor.h"
#include "state_manager.h"
#include "telemetry_manager.h"
#include "ota_manager.h"
#include "factory_test.h"
#include "audio_driver.h"

static const char *TAG = "main";
static pid_t proj_pid;

static void task_led_scene(void *arg) {
  for(;;) {
    led_scene_step(state_get_scene());
    vTaskDelay(pdMS_TO_TICKS(20));
  }
}
static void task_projector(void *arg) {
  for(;;) {
    float sensed = tilt_get_brightness_proxy();
    float u = pid_step(&proj_pid, state_get_proj_brightness() - sensed);
    hal_projector_set(u);
    vTaskDelay(pdMS_TO_TICKS(50));
  }
}
static void task_power_thermal(void *arg) {
  for(;;) {
    safety_power_thermal_guard(battery_read_voltage(), thermal_read_celsius());
    vTaskDelay(pdMS_TO_TICKS(500));
  }
}
static void task_inputs(void *arg) {
  for(;;) {
    gesture_event_t g = gesture_poll();
    if(g == GESTURE_TAP)        state_cycle_scene();
    if(g == GESTURE_SWIPE_UP)   state_increase_brightness();
    if(g == GESTURE_SWIPE_DOWN) state_decrease_brightness();
    if(g == GESTURE_LONG_PRESS) ota_begin(OTA_SERVER_URL);
    vTaskDelay(pdMS_TO_TICKS(30));
  }
}

void app_main(void) {
  ESP_LOGI(TAG, "HaloBeam boot");
  if(gpio_get_level(GPIO_BUTTON)==0){ vTaskDelay(pdMS_TO_TICKS(50)); factory_run_once(); }

  nvs_cfg_init();
  hal_init();
  led_init(LED_RING_COUNT);
  tilt_init();
  coil_init();
  battery_monitor_init();
  thermal_monitor_init();
  gesture_init(GPIO_BUTTON);
  state_init();
  telemetry_init();
  ble_start();
  ota_init();

  pid_init(&proj_pid, PID_KP, PID_KI, PID_KD, PID_DT_SEC, 0.0f, 1.0f);

  xTaskCreatePinnedToCore(task_led_scene, "led_scene", 4096, NULL, 5, NULL, 1);
  xTaskCreatePinnedToCore(task_projector, "projector", 4096, NULL, 6, NULL, 1);
  xTaskCreatePinnedToCore(task_power_thermal,"pwr_thm", 4096, NULL, 6, NULL, 0);
  xTaskCreatePinnedToCore(task_inputs, "inputs", 4096, NULL, 4, NULL, 0);

  ESP_LOGI(TAG, "HaloBeam ready. BLE: %s", BLE_DEVICE_NAME);
}

</details>

---

components/hal

<details><summary><code>components/hal/hal.h</code></summary>#pragma once
#include <stdbool.h>
#include <stdint.h>

void hal_init(void);

/* LED ring (abstracted by led_driver) */
void hal_led_strip_set_rgb(int idx, uint8_t r, uint8_t g, uint8_t b);
void hal_led_strip_show(void);

/* Projector LED (0..1) */
void hal_projector_set(float norm);

/* Servo (optional) */
void hal_servo_set_us(uint16_t us);

/* ADC reads */
float hal_adc_read_voltage(int channel);

/* GPIO helpers */
void hal_gpio_write(int pin, bool level);
bool hal_gpio_read(int pin);

/* I2C helpers */
int  hal_i2c_write(uint8_t addr, const uint8_t *buf, int len);
int  hal_i2c_read (uint8_t addr, uint8_t *buf, int len);

</details><details><summary><code>components/hal/hal.c</code></summary>#include "hal.h"
#include "driver/ledc.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "config.h"
#include <string.h>

static const char* TAG="hal";

static void i2c0_init(void){
  i2c_config_t c = {
    .mode = I2C_MODE_MASTER,
    .sda_io_num = I2C_SDA_PIN,
    .scl_io_num = I2C_SCL_PIN,
    .sda_pullup_en = GPIO_PULLUP_ENABLE,
    .scl_pullup_en = GPIO_PULLUP_ENABLE,
    .master.clk_speed = I2C_FREQ_HZ
  };
  i2c_param_config(I2C_PORT_NUM, &c);
  i2c_driver_install(I2C_PORT_NUM, I2C_MODE_MASTER, 0, 0, 0);
}

void hal_init(void){
  // Projector PWM
  ledc_timer_config_t t = {
    .speed_mode = LEDC_LOW_SPEED_MODE,
    .duty_resolution = PROJ_PWM_RES_BITS,
    .timer_num = LEDC_TIMER_0,
    .freq_hz = PROJ_PWM_FREQ_HZ
  };
  ledc_timer_config(&t);
  ledc_channel_config_t ch = {
    .gpio_num = GPIO_PROJ_PWM,
    .speed_mode = LEDC_LOW_SPEED_MODE,
    .channel = PROJ_PWM_CHANNEL,
    .timer_sel = LEDC_TIMER_0,
    .duty = 0
  };
  ledc_channel_config(&ch);

  // GPIO (Qi2 + Button)
  gpio_config_t io = {
    .pin_bit_mask = (1ULL<<GPIO_QI2_EN) | (1ULL<<GPIO_QI2_INT) | (1ULL<<GPIO_BUTTON),
    .mode = GPIO_MODE_INPUT_OUTPUT,
    .pull_up_en = 1
  };
  gpio_config(&io);
  gpio_set_level(GPIO_QI2_EN, 1);

  // I2C
  i2c0_init();

  ESP_LOGI(TAG,"HAL init done");
}

void hal_projector_set(float norm){
  if(norm<0) norm=0; if(norm>1) norm=1;
  uint32_t duty = (uint32_t)(norm * ((1<<PROJ_PWM_RES_BITS)-1));
  ledc_set_duty(LEDC_LOW_SPEED_MODE, PROJ_PWM_CHANNEL, duty);
  ledc_update_duty(LEDC_LOW_SPEED_MODE, PROJ_PWM_CHANNEL);
}

/* Stubs for LED strip low-level (handled in led_driver) */
void hal_led_strip_set_rgb(int i, uint8_t r, uint8_t g, uint8_t b){ (void)i;(void)r;(void)g;(void)b; }
void hal_led_strip_show(void){}

/* ADC/I2C helpers */
float hal_adc_read_voltage(int ch){ (void)ch; return 1.0f; } // replace if using raw ADC
int hal_i2c_write(uint8_t addr, const uint8_t *buf, int len){
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (addr<<1) | I2C_MASTER_WRITE, true);
  i2c_master_write(cmd, (uint8_t*)buf, len, true);
  i2c_master_stop(cmd);
  esp_err_t e = i2c_master_cmd_begin(I2C_PORT_NUM, cmd, pdMS_TO_TICKS(20));
  i2c_cmd_link_delete(cmd);
  return (e==ESP_OK)? len : -1;
}
int hal_i2c_read(uint8_t addr, uint8_t *buf, int len){
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (addr<<1) | I2C_MASTER_READ, true);
  if(len>1) i2c_master_read(cmd, buf, len-1, I2C_MASTER_ACK);
  i2c_master_read_byte(cmd, buf+len-1, I2C_MASTER_NACK);
  i2c_master_stop(cmd);
  esp_err_t e = i2c_master_cmd_begin(I2C_PORT_NUM, cmd, pdMS_TO_TICKS(20));
  i2c_cmd_link_delete(cmd);
  return (e==ESP_OK)? len : -1;
}
void hal_gpio_write(int pin, bool lvl){ gpio_set_level(pin, lvl); }
bool hal_gpio_read(int pin){ return gpio_get_level(pin); }
</details>

<details><summary><code>components/hal/led_driver.h</code></summary>
#pragma once
#include <stdint.h>
#include "config.h"
void led_init(int count);
void led_scene_step(int scene);
void led_set_all(uint8_t r,uint8_t g,uint8_t b);
</details>

<details><summary><code>components/hal/led_driver.c</code> (WS2812B via RMT)</summary>
#include "led_driver.h"
#include "hal.h"
#include "freertos/FreeRTOS.h"
#include "esp_log.h"
#include "led_strip.h"
#include "driver/rmt_tx.h"
#include <math.h>

static const char *TAG = "led_driver";
static led_strip_handle_t strip;
static int nled = LED_RING_COUNT;
static float t = 0.f;

void led_init(int count) {
  nled = count;

  rmt_tx_channel_config_t rmt_tx_cfg = {
    .clk_src = RMT_CLK_SRC_DEFAULT,
    .gpio_num = GPIO_LED_RING_DATA,
    .mem_block_symbols = 64,
    .resolution_hz = 10 * 1000 * 1000,
    .trans_queue_depth = 4
  };
  rmt_channel_handle_t rmt_chan;
  ESP_ERROR_CHECK(rmt_new_tx_channel(&rmt_tx_cfg, &rmt_chan));

  led_strip_config_t strip_cfg = {
    .strip_gpio_num = GPIO_LED_RING_DATA,
    .max_leds = nled,
    .led_model = LED_MODEL_WS2812,
    .flags.invert_out = false
  };
  led_strip_rmt_config_t dev_cfg = { .resolution_hz = 10*1000*1000 };
  ESP_ERROR_CHECK(led_strip_new_rmt_device(&strip_cfg, &dev_cfg, &strip));
  ESP_LOGI(TAG, "WS2812B strip init ok: %d pixels", nled);
  led_set_all(0,0,0);
}

static inline void set_px(int i, uint8_t r,uint8_t g,uint8_t b){
  led_strip_set_pixel(strip, i, r, g, b);
}
void led_set_all(uint8_t r,uint8_t g,uint8_t b){
  for(int i=0;i<nled;i++) set_px(i,r,g,b);
  led_strip_refresh(strip);
}

static void scene_warm_wake(void){
  for(int i=0;i<nled;i++){
    float k = 0.5f + 0.5f*sinf(t + i*0.20f);
    set_px(i,(uint8_t)(220*k),(uint8_t)(80*k),10);
  }
  led_strip_refresh(strip); t+=0.05f;
}
static void scene_focus_cool(void){
  for(int i=0;i<nled;i++){
    float k = 0.6f + 0.4f*sinf(t + i*0.15f);
    set_px(i,20,(uint8_t)(120*k),(uint8_t)(210*k));
  }
  led_strip_refresh(strip); t+=0.04f;
}
static void scene_sleep_amber(void){ led_set_all(255,100,0); }
static void scene_aurora(void){
  for(int i=0;i<nled;i++){
    float k1 = 0.5f + 0.5f*sinf(t + i*0.12f);
    float k2 = 0.5f + 0.5f*sinf(t*0.7f + i*0.08f);
    set_px(i,(uint8_t)(30*k2),(uint8_t)(160*k1),(uint8_t)(220*k2));
  }
  led_strip_refresh(strip); t+=0.03f;
}
static void scene_starry(void){
  led_set_all(5,5,10);
  int idx = ((int)(t*37))%nled;
  set_px(idx,180,180,255);
  led_strip_refresh(strip); t+=0.05f;
}

void led_scene_step(int scene){
  switch(scene){
    case SCENE_WARM_WAKE:   scene_warm_wake();  break;
    case SCENE_FOCUS_COOL:  scene_focus_cool(); break;
    case SCENE_SLEEP_AMBER: scene_sleep_amber();break;
    case SCENE_AURORA:      scene_aurora();     break;
    default:                scene_starry();     break;
  }
}
</details>

<details><summary><code>components/hal/tilt_sensor.h</code></summary>
#pragma once
void tilt_init(void);
float tilt_get_roll_deg(void);
float tilt_get_brightness_proxy(void); // 0..1
</details>

<details><summary><code>components/hal/tilt_sensor.c</code> (ICM-42670)</summary>
#include "tilt_sensor.h"
#include "hal.h"
#include "esp_log.h"
#include <math.h>
#include <string.h>

static const char *TAG = "imu";

/* Verify these for your sub-variant */
#define IMU_ADDR          0x68
#define REG_WHO_AM_I      0x75
#define REG_PWR_MGMT0     0x4E
#define REG_ACCEL_CONFIG0 0x50
#define REG_ACCEL_DATA_X0 0x1F

static int16_t rd16(uint8_t hi, uint8_t lo){ return (int16_t)((hi<<8)|lo); }
static int i2c_write_reg(uint8_t reg, uint8_t val){
  uint8_t b[2] = {reg,val}; return hal_i2c_write(IMU_ADDR, b, 2);
}
static int i2c_read_regs(uint8_t reg, uint8_t* buf, int len){
  hal_i2c_write(IMU_ADDR, &reg, 1);
  return hal_i2c_read(IMU_ADDR, buf, len);
}

void tilt_init(void){
  uint8_t who=0; i2c_read_regs(REG_WHO_AM_I, &who, 1);
  ESP_LOGI(TAG,"WHO_AM_I=0x%02X", who);
  i2c_write_reg(REG_PWR_MGMT0, 0x0F); // accel LN, gyro off
  i2c_write_reg(REG_ACCEL_CONFIG0, 0x06); // 16g, ~1kHz ODR
  ESP_LOGI(TAG,"ICM-42670 init complete");
}

float tilt_get_roll_deg(void){
  uint8_t d[6]={0};
  if(i2c_read_regs(REG_ACCEL_DATA_X0, d, 6) != 6) return 0.f;
  int16_t x = rd16(d[0], d[1]);
  int16_t y = rd16(d[2], d[3]);
  int16_t z = rd16(d[4], d[5]);
  float xg = (float)x / 2048.f;
  float yg = (float)y / 2048.f;
  float zg = (float)z / 2048.f;
  return atan2f(-xg, sqrtf(yg*yg + zg*zg)) * 180.0f / (float)M_PI;
}

float tilt_get_brightness_proxy(void){
  float roll = fabsf(tilt_get_roll_deg());
  float b = 1.0f - (roll / 15.0f);
  if(b<0) b=0; if(b>1) b=1; return b;
}
</details>

<details><summary><code>components/hal/coil_driver.h</code></summary>
#pragma once
typedef enum { QI2_IDLE, QI2_CHARGING, QI2_FAULT } qi2_state_t;
void coil_init(void);
void coil_poll(void);        // no-op with ISR, kept for API compatibility
qi2_state_t coil_get_state(void);
</details>

<details><summary><code>components/hal/coil_driver.c</code> (Qi2 ISR)</summary>
#include "coil_driver.h"
#include "hal.h"
#include "config.h"
#include "esp_log.h"
#include "driver/gpio.h"
#include "freertos/queue.h"
#include "freertos/task.h"

static const char* TAG = "qi2";
static qi2_state_t state = QI2_IDLE;
static QueueHandle_t gpio_evt_queue;

static void IRAM_ATTR gpio_isr(void* arg){
  uint32_t gp = (uint32_t)arg;
  xQueueSendFromISR(gpio_evt_queue, &gp, NULL);
}

static void coil_task(void* arg){
  uint32_t io;
  for(;;){
    if(xQueueReceive(gpio_evt_queue,&io,portMAX_DELAY)){
      bool level = hal_gpio_read(io);      // active-low IRQ
      if(!level){
        state = QI2_CHARGING;
        ESP_LOGI(TAG,"Qi2: charging started");
      }else{
        state = QI2_IDLE;
        ESP_LOGI(TAG,"Qi2: charging stopped");
      }
    }
  }
}

void coil_init(void){
  hal_gpio_write(GPIO_QI2_EN, 1);
  gpio_evt_queue = xQueueCreate(8, sizeof(uint32_t));
  xTaskCreate(coil_task, "qi2_task", 4096, NULL, 10, NULL);

  gpio_config_t io = {
    .pin_bit_mask = 1ULL<<GPIO_QI2_INT,
    .mode = GPIO_MODE_INPUT,
    .pull_up_en = 1,
    .intr_type = GPIO_INTR_ANYEDGE
  };
  gpio_config(&io);
  gpio_install_isr_service(0);
  gpio_isr_handler_add(GPIO_QI2_INT, gpio_isr, (void*)GPIO_QI2_INT);

  ESP_LOGI(TAG,"Qi2 driver ready (INT=%d)", GPIO_QI2_INT);
}
void coil_poll(void){}
qi2_state_t coil_get_state(void){ return state; }
</details>

<details><summary><code>components/hal/audio_driver.h</code></summary>
#pragma once
#include "config.h"
void audio_init(void);
void audio_play_scene(scene_t scene);
</details>

<details><summary><code>components/hal/audio_driver.c</code></summary>
#include "audio_driver.h"
#include "esp_log.h"
#include "driver/i2s_std.h"
#include <math.h>
#include <string.h>

static const char *TAG = "audio";
static i2s_chan_handle_t tx_handle;

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

static int16_t audio_buffer[1024];

static void generate_sine_wave(int freq_hz, int sample_rate) {
    for (int i = 0; i < 1024; i++) {
        float ph = 2.0f * (float)M_PI * (float)freq_hz * (float)i / (float)sample_rate;
        audio_buffer[i] = (int16_t)(sinf(ph) * 30000.0f);
    }
}

void audio_init(void) {
    i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_handle, NULL));

    i2s_std_config_t std_cfg = {
        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(44100),
        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = I2S_GPIO_UNUSED,
            .bclk = I2S_BCLK_PIN,
            .ws   = I2S_WS_PIN,
            .dout = I2S_DATA_PIN,
            .din  = I2S_GPIO_UNUSED,
        },
    };
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_handle, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));

    generate_sine_wave(440, 44100);
    ESP_LOGI(TAG, "I2S audio init (MAX98357A, 44.1 kHz, 16-bit stereo)");
}

void audio_play_scene(scene_t scene) {
    size_t written;
    int freq = 0;  // 0 = mute

    switch (scene) {
        case SCENE_WARM_WAKE:  freq = 440; break;
        case SCENE_FOCUS_COOL: freq = 880; break;
        case SCENE_AURORA:     freq = 220; break;
        case SCENE_STARRY:     freq = 660; break;
        default:               freq = 0;   break;
    }

    if (freq > 0) {
        generate_sine_wave(freq, 44100);
        static int16_t stereo[2048];
        for (int i = 0; i < 1024; ++i) {
            stereo[2*i] = stereo[2*i+1] = audio_buffer[i];
        }
        ESP_ERROR_CHECK(i2s_channel_write(tx_handle, stereo, sizeof(stereo), &written, portMAX_DELAY));
    }
}
</details>

---

components/power

<details><summary><code>components/power/battery_monitor.h</code></summary>
#pragma once
void battery_monitor_init(void);
float battery_read_voltage(void);
float battery_pct_from_voltage(float v);
</details>

<details><summary><code>components/power/battery_monitor.c</code></summary>
#include "battery_monitor.h"
#include "hal.h"
#include "config.h"
#include <math.h>

/* Calibrate for your divider and ADC ref */
static const float RTOP  = 560000.0f;  // 560k
static const float RBOT  = 100000.0f;  // 100k
static const float ADC_VREF = 1.100f;  // adjust if using raw ADC API
static const float ADC_SCALE = (RTOP + RBOT) / RBOT; // ~6.6

void battery_monitor_init(void){}

float battery_read_voltage(void){
  float vadc = hal_adc_read_voltage(ADC_BATT_CH);  // volts at ADC pin
  return vadc * ADC_SCALE;
}

float battery_pct_from_voltage(float v){
  if(v < 3.40f) return 0;
  if(v > 4.20f) return 100;
  const float table[][2] = {
    {3.40f, 0}, {3.55f,10}, {3.70f,30}, {3.80f,50},
    {3.90f,70}, {4.00f,85}, {4.10f,95}, {4.20f,100}
  };
  for(int i=1;i<8;i++){
    if(v <= table[i][0]){
      float x0=table[i-1][0], y0=table[i-1][1];
      float x1=table[i][0],   y1=table[i][1];
      return y0 + (y1-y0)*(v-x0)/(x1-x0);
    }
  }
  return 100;
}
</details>

<details><summary><code>components/power/thermal_monitor.h</code></summary>
#pragma once
void thermal_monitor_init(void);
float thermal_read_celsius(void);
</details>

<details><summary><code>components/power/thermal_monitor.c</code></summary>
#include "thermal_monitor.h"
#include "hal.h"
#include "config.h"
#include <math.h>

/* Example NTC: 10k@25C, Beta 3950 */
static const float R_SERIES = 10000.0f;
static const float BETA     = 3950.0f;
static const float T0       = 298.15f;    // 25C
static const float R0       = 10000.0f;

void thermal_monitor_init(void){}

float thermal_read_celsius(void){
  float vadc = hal_adc_read_voltage(NTC_ADC_CH); // V at divider midpoint
  float vcc = 3.3f;
  if(vadc <= 0.001f) vadc = 0.001f;
  if(vadc >= vcc-0.001f) vadc = vcc-0.001f;

  float r_ntc = (vadc * R_SERIES) / (vcc - vadc); // NTC to ground
  float invT = (1.0f/T0) + (1.0f/BETA) * logf(r_ntc / R0);
  float TK = 1.0f / invT;
  return TK - 273.15f;
}
</details>

---

components/pid

<details><summary><code>components/pid/pid_control.h</code></summary>
#pragma once
typedef struct { float kp, ki, kd, dt, min,max, integ, prev; } pid_t;
void pid_init(pid_t* p,float kp,float ki,float kd,float dt,float mn,float mx);
float pid_step(pid_t* p, float err);
</details>

<details><summary><code>components/pid/pid_control.c</code></summary>
#include "pid_control.h"
void pid_init(pid_t* p,float kp,float ki,float kd,float dt,float mn,float mx){
  p->kp=kp;p->ki=ki;p->kd=kd;p->dt=dt;p->min=mn;p->max=mx;p->integ=0;p->prev=0;
}
float pid_step(pid_t* p, float e){
  p->integ += e * p->dt;
  float deriv = (e - p->prev)/p->dt;
  float u = p->kp*e + p->ki*p->integ + p->kd*deriv;
  if(u<p->min) u=p->min;
  if(u>p->max) u=p->max;
  p->prev = e;
  return u;
}
</details>

---

components/ble

<details><summary><code>components/ble/ble_gatt_server.h</code></summary>
#pragma once
void ble_start(void);
</details>

<details><summary><code>components/ble/ble_gatt_server.c</code></summary>
#include "ble_gatt_server.h"
#include "esp_log.h"
#include "esp_bt.h"
#include "esp_gap_ble_api.h"
#include "esp_gatts_api.h"
#include "esp_bt_main.h"
#include "config.h"
#include "state_manager.h"
#include "thermal_monitor.h"
#include "nvs_config.h"
#include <string.h>

static const char *TAG = "ble";

#define SVC_UUID        0xFFF0
#define CHAR_SCENE_UUID 0xFFF1
#define CHAR_BRIGHT_UUID 0xFFF2
#define CHAR_TEMP_UUID  0xFFF3
#define CHAR_OTA_UUID   0xFFF4
define CHAR_WIFI_UUID  0xFFF5

enum {
  IDX_SVC,
  IDX_CHAR_SCENE, IDX_CHAR_SCENE_VAL,
  IDX_CHAR_BRIGHT,IDX_CHAR_BRIGHT_VAL,
  IDX_CHAR_TEMP,  IDX_CHAR_TEMP_VAL,
  IDX_CHAR_OTA,   IDX_CHAR_OTA_VAL,
  IDX_CHAR_WIFI,  IDX_CHAR_WIFI_VAL,
  HIDX_COUNT
};
static uint16_t handle_table[HIDX_COUNT];

static const uint16_t primary_service_uuid       = ESP_GATT_UUID_PRI_SERVICE;
static const uint16_t char_decl_uuid             = ESP_GATT_UUID_CHAR_DECLARE;
static const uint8_t  prop_rw = ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE;
static const uint8_t  prop_r  = ESP_GATT_CHAR_PROP_BIT_READ;
static const uint8_t  prop_w  = ESP_GATT_CHAR_PROP_BIT_WRITE;

static const esp_gatts_attr_db_t gatt_db[HIDX_COUNT] = {
  [IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&primary_service_uuid, ESP_GATT_PERM_READ,
                                      sizeof(uint16_t), sizeof(uint16_t),(uint8_t*)&(uint16_t){SVC_UUID}}},
  [IDX_CHAR_SCENE]     = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&char_decl_uuid, ESP_GATT_PERM_READ,
                                      sizeof(uint8_t), sizeof(uint8_t),(uint8_t*)&prop_rw}},
  [IDX_CHAR_SCENE_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&(uint16_t){CHAR_SCENE_UUID},
                                      ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE, 1,1,(uint8_t[]){0}}},
  [IDX_CHAR_BRIGHT]     = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&char_decl_uuid, ESP_GATT_PERM_READ,
                                      sizeof(uint8_t), sizeof(uint8_t),(uint8_t*)&prop_rw}},
  [IDX_CHAR_BRIGHT_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&(uint16_t){CHAR_BRIGHT_UUID},
                                      ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE, 1,1,(uint8_t[]){80}}},
  [IDX_CHAR_TEMP]     = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&char_decl_uuid, ESP_GATT_PERM_READ,
                                      sizeof(uint8_t), sizeof(uint8_t),(uint8_t*)&prop_r}},
  [IDX_CHAR_TEMP_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&(uint16_t){CHAR_TEMP_UUID},
                                      ESP_GATT_PERM_READ, 1,1,(uint8_t[]){25}}},
  [IDX_CHAR_OTA]     = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&char_decl_uuid, ESP_GATT_PERM_READ,
                                      sizeof(uint8_t), sizeof(uint8_t),(uint8_t*)&prop_w}},
  [IDX_CHAR_OTA_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&(uint16_t){CHAR_OTA_UUID},
                                      ESP_GATT_PERM_WRITE, 1,1,(uint8_t[]){0}}},
  [IDX_CHAR_WIFI]     = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&char_decl_uuid, ESP_GATT_PERM_READ,
                                      sizeof(uint8_t), sizeof(uint8_t),(uint8_t*)&prop_w}},
  [IDX_CHAR_WIFI_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16,(uint8_t*)&(uint16_t){CHAR_WIFI_UUID},
                                      ESP_GATT_PERM_WRITE, 1,1,(uint8_t[]){0}}},
};

static void gap_cb(esp_gap_ble_cb_event_t e, esp_ble_gap_cb_param_t *p){
  if(e==ESP_GAP_BLE_ADV_START_COMPLETE_EVT)
    ESP_LOGI(TAG,"Adv start %s", p->adv_start_cmpl.status==ESP_BT_STATUS_SUCCESS?"ok":"fail");
}
static void gatts_cb(esp_gatts_cb_event_t e, esp_gatt_if_t ifx, esp_ble_gatts_cb_param_t *p){
  switch(e){
    case ESP_GATTS_REG_EVT:
      esp_ble_gap_set_device_name(BLE_DEVICE_NAME);
      esp_ble_gatts_create_attr_tab(gatt_db, ifx, HIDX_COUNT, 0);
      break;
    case ESP_GATTS_CREAT_ATTR_TAB_EVT:
      if(p->add_attr_tab.status == ESP_GATT_OK){
        memcpy(handle_table, p->add_attr_tab.handles, sizeof(handle_table));
        esp_ble_gatts_start_service(handle_table[IDX_SVC]);
        esp_ble_adv_params_t adv = {
          .adv_int_min = 0x20, .adv_int_max = 0x40,
          .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
          .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY
        };
        uint8_t adv_data[] = { 0x02,0x01,0x06, 0x03,0x03,(uint8_t)(SVC_UUID&0xFF),(uint8_t)(SVC_UUID>>8) };
        esp_ble_gap_config_adv_data_raw(adv_data, sizeof(adv_data));
        esp_ble_gap_register_callback(gap_cb);
        esp_ble_gap_start_advertising(&adv);
      }
      break;
    case ESP_GATTS_WRITE_EVT: {
      uint16_t h = p->write.handle; const uint8_t *v=p->write.value; uint16_t L=p->write.len;
      if(h==handle_table[IDX_CHAR_SCENE_VAL] && L==1)          state_set_scene((scene_t)v[0]);
      else if(h==handle_table[IDX_CHAR_BRIGHT_VAL] && L==1)    state_set_proj_brightness((float)v[0]/100.f);
      else if(h==handle_table[IDX_CHAR_OTA_VAL] && L>=5)       /* ota_begin((const char*)v); */ (void)0; // enable when ready
      if(p->write.need_rsp) esp_ble_gatts_send_response(ifx, p->write.conn_id, p->write.trans_id, ESP_GATT_OK, NULL);
    } break;
    case ESP_GATTS_READ_EVT: {
      uint8_t out=0;
      if(p->read.handle==handle_table[IDX_CHAR_TEMP_VAL]){
        float tC = thermal_read_celsius(); out = (uint8_t)(tC<0?0:(tC>255?255:tC));
      } else if(p->read.handle==handle_table[IDX_CHAR_SCENE_VAL]){
        out = (uint8_t)state_get_scene();
      } else if(p->read.handle==handle_table[IDX_CHAR_BRIGHT_VAL]){
        out = (uint8_t)(state_get_proj_brightness()*100.f);
      }
      esp_gatt_rsp_t rsp={0}; rsp.attr_value.handle=p->read.handle; rsp.attr_value.len=1; rsp.attr_value.value[0]=out;
      esp_ble_gatts_send_response(ifx, p->read.conn_id, p->read.trans_id, ESP_GATT_OK, &rsp);
    } break;
    default: break;
  }
}
void ble_start(void){
  esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT);
  esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
  esp_bt_controller_init(&bt_cfg);
  esp_bt_controller_enable(ESP_BT_MODE_BLE);
  esp_bluedroid_init(); esp_bluedroid_enable();
  esp_ble_gatts_register_callback(gatts_cb);
  esp_ble_gatts_app_register(0);
  ESP_LOGI(TAG,"BLE GATT server up: %s", BLE_DEVICE_NAME);
}

</details>

---

components/safety

<details><summary><code>components/safety/safety_manager.h</code></summary>
#pragma once
void safety_power_thermal_guard(float vbat, float tC);
</details>

<details><summary><code>components/safety/safety_manager.c</code></summary>
#include "safety_manager.h"
#include "config.h"
#include "hal.h"
#include "led_driver.h"

void safety_power_thermal_guard(float v, float tC){
  if(tC > T_LIMIT_C){ hal_projector_set(0.0f); led_set_all(255,0,0); }
  else if(tC > T_WARN_C){ hal_projector_set(0.5f); }
  if(v < VBATT_CRIT_V){ hal_projector_set(0.0f); }
}
</details>

<details><summary><code>components/safety/watchdogs.h</code></summary>
#pragma once
void wd_init(void);
void wd_feed(void);
</details>

<details><summary><code>components/safety/watchdogs.c</code></summary>
#include "watchdogs.h"
void wd_init(void){}
void wd_feed(void){}
</details>

---

components/nvs_config

<details><summary><code>components/nvs_config/nvs_config.h</code></summary>
#pragma once
void nvs_cfg_init(void);
</details>

<details><summary><code>components/nvs_config/nvs_config.c</code></summary>
#include "nvs_flash.h"
#include "nvs_config.h"
void nvs_cfg_init(void){ nvs_flash_init(); }
</details>

---

components/input

<details><summary><code>components/input/gesture_sensor.h</code></summary>
#pragma once
typedef enum { GESTURE_NONE, GESTURE_TAP, GESTURE_SWIPE_UP, GESTURE_SWIPE_DOWN, GESTURE_LONG_PRESS } gesture_event_t;
void gesture_init(int btn_gpio);
gesture_event_t gesture_poll(void);
</details>

<details><summary><code>components/input/gesture_sensor.c</code></summary>
#include "gesture_sensor.h"
#include "driver/gpio.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static int BTN_GPIO;
static int last = 1;
static uint32_t down_ms = 0;
static const uint32_t DEBOUNCE_MS = 25;
static const uint32_t LONG_MS     = 1200;

static uint32_t now_ms(void){ return (uint32_t)(xTaskGetTickCount()*portTICK_PERIOD_MS); }

void gesture_init(int btn_gpio){
  BTN_GPIO = btn_gpio;
  gpio_set_direction(BTN_GPIO, GPIO_MODE_INPUT);
  gpio_pullup_en(BTN_GPIO);
}

gesture_event_t gesture_poll(void){
  int v = gpio_get_level(BTN_GPIO);
  static uint32_t last_chg_ms = 0;
  uint32_t now = now_ms();

  if(v != last && (now - last_chg_ms) > DEBOUNCE_MS){
    last_chg_ms = now;
    last = v;
    if(v==0){ down_ms = now; }
    else{
      if(down_ms && (now - down_ms) >= LONG_MS) return GESTURE_LONG_PRESS;
      if(down_ms) return GESTURE_TAP;
    }
  }
  return GESTURE_NONE;
}
</details>

<details><summary><code>components/input/rotary.c</code></summary>
/* Optional rotary support placeholder */
</details>

---

components/logging

<details><summary><code>components/logging/fault_logger.h</code></summary>
#pragma once
void fault_log(const char* msg);
</details>

<details><summary><code>components/logging/fault_logger.c</code></summary>
#include "fault_logger.h"
#include "esp_log.h"
static const char* TAG="fault";
void fault_log(const char* msg){ ESP_LOGE(TAG, "%s", msg); }
</details>

<details><summary><code>components/logging/ringlog.c</code></summary>
/* Minimal ring log placeholder; expand if desired */
</details>

---

components/state

<details><summary><code>components/state/state_manager.h</code></summary>
#pragma once
#include "config.h"
void state_init(void);
void state_cycle_scene(void);
void state_increase_brightness(void);
void state_decrease_brightness(void);
scene_t state_get_scene(void);
float state_get_proj_brightness(void);
void state_set_scene(scene_t s);
void state_set_proj_brightness(float b);
void state_set_projection_mode(proj_mode_t mode);
</details>

<details><summary><code>components/state/state_manager.c</code></summary>
#include "state_manager.h"
static scene_t scene = SCENE_AURORA;
static float proj_b = 0.8f;
static proj_mode_t proj_mode = PROJ_AURORA;

void state_init(void){ scene = SCENE_AURORA; proj_b=0.8f; proj_mode=PROJ_AURORA; }
void state_cycle_scene(void){ scene = (scene_t)((scene+1)%5); }
void state_increase_brightness(void){ proj_b += 0.05f; if(proj_b>1) proj_b=1; }
void state_decrease_brightness(void){ proj_b -= 0.05f; if(proj_b<0.1f) proj_b=0.1f; }
scene_t state_get_scene(void){ return scene; }
float state_get_proj_brightness(void){ return proj_b; }
void state_set_scene(scene_t s){ scene = s; }
void state_set_proj_brightness(float b){ if(b<0.1f)b=0.1f; if(b>1)b=1; proj_b=b; }
void state_set_projection_mode(proj_mode_t mode){ proj_mode = mode; }
</details>

<details><summary><code>components/state/factory_test.h</code></summary>
#pragma once
void factory_run_once(void);
</details>

<details><summary><code>components/state/factory_test.c</code></summary>
#include "factory_test.h"
#include "led_driver.h"
#include "coil_driver.h"
#include "thermal_monitor.h"
#include "battery_monitor.h"
#include "hal.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char* TAG="factory";

void factory_run_once(void){
  ESP_LOGI(TAG,"=== HALOBEAM FACTORY TEST ===");
  for(int s=0; s<5; ++s){ led_scene_step(s); vTaskDelay(pdMS_TO_TICKS(500)); }
  led_set_all(0,0,0);

  for(float b=0;b<=1.0f;b+=0.1f){ hal_projector_set(b); vTaskDelay(pdMS_TO_TICKS(150)); }
  hal_projector_set(0.2f);

  qi2_state_t q = coil_get_state();
  ESP_LOGI(TAG,"Qi2 state: %s", q==QI2_CHARGING?"CHARGING":"IDLE");

  float tC = thermal_read_celsius();
  float vbat = battery_read_voltage();
  ESP_LOGI(TAG,"Temp: %.1f C | Vbat: %.2f V (SOC ~%.0f%%)", tC, vbat, battery_pct_from_voltage(vbat));
  ESP_LOGI(TAG,"=== TEST COMPLETE ===");
}
</details>

---

components/telemetry

<details><summary><code>components/telemetry/telemetry_manager.h</code></summary>
#pragma once
void telemetry_init(void);
</details>

<details><summary><code>components/telemetry/telemetry_manager.c</code></summary>
#include "telemetry_manager.h"
/* reserve hooks for BLE/serial export */

void telemetry_init(void){}
</details>

---

components/ota

<details><summary><code>components/ota/ota_manager.h</code></summary>
#pragma once
void ota_init(void);
void ota_begin(const char* https_url);
</details>

<details><summary><code>components/ota/ota_manager.c</code></summary>
#include "ota_manager.h"
#include "esp_https_ota.h"
#include "esp_log.h"
#include "esp_wifi.h"

static const char* TAG="ota";

/* Link your server root CA as binary:
   Add PEM to your project and link with symbols below. */
extern const uint8_t server_root_cert_pem_start[] asm("_binary_server_root_cert_pem_start");
extern const uint8_t server_root_cert_pem_end[]   asm("_binary_server_root_cert_pem_end");

void ota_init(void){}

void ota_begin(const char* https_url){
  esp_http_client_config_t http_cfg = {
    .url = https_url,
    .cert_pem = (const char*)server_root_cert_pem_start,
    .keep_alive_enable = true,
    .timeout_ms = 15000
  };
  esp_https_ota_config_t ota_cfg = { .http_config = &http_cfg };

  ESP_LOGI(TAG,"Starting OTA: %s", https_url);
  esp_err_t ret = esp_https_ota(&ota_cfg);
  if (ret == ESP_OK){
    ESP_LOGI(TAG,"OTA successful, rebooting");
    esp_restart();
  }else{
    ESP_LOGE(TAG,"OTA failed: %s", esp_err_to_name(ret));
  }
}
</details>

---

QA / Compliance

EMC/Safety: FCC/CE/UKCA targets; Qi2 compliance; RoHS; DOE VI PSU

Thermal policy: derate >55 °C; cutoff ≥65 °C; exterior <50 °C at touch points

AQL: 0.65 major / 1.0 minor; 5% burn-in 24 h; ESD 8 kV air / 4 kV contact (critical points)



---

BOM & Pricing

COGS (Lite): ~$55–$70 · Pro: ~$70–$90 · Beam+: ~$85–$110

KS Early / KS Std / MSRP: $89 / $99 / $129 (Lite), $129 / $149–179 / $199 (Pro), $169 / $199–229 / $259 (Beam+)

Add-ons: extra caps $25; silicone mat $12; sleeve $15



---

Factory Test Checklist

LED ring pixel/scene sweep ✔

Projector PWM sweep → lux @ 1 m ✔

Qi2 start/stop interrupt ✔

Temp (NTC) / Battery voltage read ✔

BLE read/write (scene, brightness, temp) ✔



---

Troubleshooting

LED strip / RMT symbols: ensure led_strip component; idf.py fullclean && build.

No audio: verify I2S pins; try I2S_STD_CLK_DEFAULT_CONFIG(22050) for bring-up.

BLE not discoverable: power cycle; Android/iOS scan refresh; long-press to re-advertise.

OTA fails: embed correct root CA; confirm OTA_SERVER_URL reachable; provision Wi-Fi via GATT.

ADC off by >0.1 V: use IDF ADC calibration; update divider constants from actual resistors.



---

Production Notes

ADC calibration (optional, higher accuracy):

// Replace hal_adc_read_voltage() using adc_cali_* APIs; enable CONFIG_ADC_CALI_ENABLED=y

OTA certificate embedding (CMake):

# components/ota/CMakeLists.txt (alternative if you split it out)
idf_component_register(SRCS "ota_manager.c"
                      INCLUDE_DIRS "."
                      PRIV_REQUIRES esp_https_ota esp_wifi nvs_flash
                      EMBED_FILES server_root_cert.pem)

EMC: add ferrites on speaker/Qi harness; TVS at USB-C; short WS2812 data + series 330–470 Ω.


---


#Mermaid (renders)



---

1) docs/scene_flow.dot (Graphviz — export SVG/PNG)

digraph HaloBeam_SceneFlow {
  rankdir=LR;
  fontsize=12;
  labelloc="t";
  label="HaloBeam™ Scene → Runtime Flow (v1.0)";

  node [shape=box, style="rounded,filled", fillcolor="#f7f7f9", color="#c0c4cc", fontname="Inter, Helvetica, Arial"];

  subgraph cluster_ui {
    label="User & App";
    color="#e5e7eb";
    "App / BLE Client" [shape=box3d, fillcolor="#eef2ff"];
    "Crown Button\n(GPIO0)" [fillcolor="#eef2ff"];
  }

  subgraph cluster_ble {
    label="BLE GATT (0xFFF0)";
    color="#e5e7eb";
    "CHAR_SCENE\n0xFFF1 (u8)";
    "CHAR_BRIGHT\n0xFFF2 (u8 10–100)";
    "CHAR_TIME\n0xFFF6 (u32)";
    "CHAR_WIFI\n0xFFF5 (...)";
    "CHAR_OTA_URL\n0xFFF4 (url)";
  }

  subgraph cluster_fw {
    label="Firmware Runtime";
    color="#e5e7eb";
    "state_manager.c\n(scenes, brightness)" [fillcolor="#fff7ed"];
    "gesture_sensor.c";
    "pid_control.c\n(PWM target)";
    "led_driver.c\n(Ring scenes)";
    "projector PWM\n(GPIO4, LEDC)";
    "ssd1306.c\n(Info Cap)";
    "audio_driver.c\n(I2S → MAX98357A)";
    "safety_manager.c\n(thermal/battery guards)" [fillcolor="#fde68a"];
  }

  subgraph cluster_sensors {
    label="Sensors / Monitors";
    color="#e5e7eb";
    "IMU ICM-42670\n(I2C @0x68)";
    "NTC Thermistor";
    "Battery ADC";
    "Qi2 Coil IRQ\n(GPIO10)";
  }

  subgraph cluster_outputs {
    label="Outputs";
    color="#e5e7eb";
    "Halo LED Ring\n(WS2812B, RMT@GPIO18)" [fillcolor="#ecfeff"];
    "Ceiling Projection\n(2–5W LED via PWM)" [fillcolor="#ecfeff"];
    "Audio Tones\n(I2S 44.1k/16b)" [fillcolor="#ecfeff"];
    "OLED Info Cap\n(SSD1306 @0x3C)" [fillcolor="#ecfeff"];
  }

  // User/App → BLE
  "App / BLE Client" -> "CHAR_SCENE\n0xFFF1 (u8)" [label=" set scene"];
  "App / BLE Client" -> "CHAR_BRIGHT\n0xFFF2 (u8 10–100)" [label=" set brightness"];
  "App / BLE Client" -> "CHAR_TIME\n0xFFF6 (u32)" [label=" set clock"];
  "App / BLE Client" -> "CHAR_WIFI\n0xFFF5 (...)" [label=" provision Wi-Fi"];
  "App / BLE Client" -> "CHAR_OTA_URL\n0xFFF4 (url)" [label=" OTA request"];
  "Crown Button\n(GPIO0)" -> "gesture_sensor.c" [label=" tap/long press"];

  // BLE → State
  "CHAR_SCENE\n0xFFF1 (u8)" -> "state_manager.c\n(scenes, brightness)";
  "CHAR_BRIGHT\n0xFFF2 (u8 10–100)" -> "state_manager.c\n(scenes, brightness)";
  "CHAR_TIME\n0xFFF6 (u32)" -> "ssd1306.c\n(Info Cap)";
  "CHAR_OTA_URL\n0xFFF4 (url)" -> "safety_manager.c\n(thermal/battery guards)" [style=dashed, color="#9ca3af"];
  "gesture_sensor.c" -> "state_manager.c\n(scenes, brightness)";

  // State → Render Paths
  "state_manager.c\n(scenes, brightness)" -> "led_driver.c\n(Ring scenes)" [label=" halo scene id"];
  "state_manager.c\n(scenes, brightness)" -> "pid_control.c\n(PWM target)" [label=" target brightness"];
  "state_manager.c\n(scenes, brightness)" -> "audio_driver.c\n(I2S → MAX98357A)" [label=" scene tone"];
  "state_manager.c\n(scenes, brightness)" -> "ssd1306.c\n(Info Cap)" [label=" glyphs/time (if mode)"];

  // Sensors → Guards / PID
  "IMU ICM-42670\n(I2C @0x68)" -> "pid_control.c\n(PWM target)" [label=" tilt→ambient proxy"];
  "NTC Thermistor" -> "safety_manager.c\n(thermal/battery guards)" [label=" °C"];
  "Battery ADC" -> "safety_manager.c\n(thermal/battery guards)" [label=" Vbat"];
  "Qi2 Coil IRQ\n(GPIO10)" -> "safety_manager.c\n(thermal/battery guards)" [label=" charge state"];

  // Render modules → Outputs
  "led_driver.c\n(Ring scenes)" -> "Halo LED Ring\n(WS2812B, RMT@GPIO18)";
  "pid_control.c\n(PWM target)" -> "projector PWM\n(GPIO4, LEDC)";
  "ssd1306.c\n(Info Cap)" -> "OLED Info Cap\n(SSD1306 @0x3C)";
  "audio_driver.c\n(I2S → MAX98357A)" -> "Audio Tones\n(I2S 44.1k/16b)";

  // Guards enforce limits
  "safety_manager.c\n(thermal/battery guards)" -> "projector PWM\n(GPIO4, LEDC)" [label=" derate/cutoff"];
  "safety_manager.c\n(thermal/battery guards)" -> "Halo LED Ring\n(WS2812B, RMT@GPIO18)" [label=" alert (red)"];

  // Styling ranks
  {rank=same; "App / BLE Client"; "Crown Button\n(GPIO0)";}
  {rank=same; "CHAR_SCENE\n0xFFF1 (u8)"; "CHAR_BRIGHT\n0xFFF2 (u8 10–100)"; "CHAR_TIME\n0xFFF6 (u32)"; "CHAR_WIFI\n0xFFF5 (...)"; "CHAR_OTA_URL\n0xFFF4 (url)";}
  {rank=same; "led_driver.c\n(Ring scenes)"; "pid_control.c\n(PWM target)"; "audio_driver.c\n(I2S → MAX98357A)"; "ssd1306.c\n(Info Cap)";}
  {rank=same; "Halo LED Ring\n(WS2812B, RMT@GPIO18)"; "Ceiling Projection\n(2–5W LED via PWM)"; "Audio Tones\n(I2S 44.1k/16b)"; "OLED Info Cap\n(SSD1306 @0x3C)";}
}

Export locally

# SVG
dot -Tsvg docs/scene_flow.dot -o docs/img/scene_flow.svg
# PNG (for README if you prefer)
dot -Tpng docs/scene_flow.dot -o docs/img/scene_flow.png


---

2) docs/scene_flow.mmd (Mermaid — paste in README to render on GitHub)

flowchart LR
  %% HaloBeam™ Scene → Runtime Flow (v1.0)
  classDef box fill:#f7f7f9,stroke:#c0c4cc,rx:6,ry:6,color:#111;
  classDef hi fill:#fff7ed,stroke:#f59e0b,rx:6,ry:6,color:#111;
  classDef out fill:#ecfeff,stroke:#06b6d4,rx:6,ry:6,color:#111;

  subgraph U[User & App]
    A[App / BLE Client]:::box
    B[Crown Button (GPIO0)]:::box
  end

  subgraph G[BLE GATT (0xFFF0)]
    C1[SCENE 0xFFF1 (u8)]:::box
    C2[BRIGHT 0xFFF2 (u8)]:::box
    C3[TIME 0xFFF6 (u32)]:::box
    C4[WIFI 0xFFF5 (...)]:::box
    C5[OTA_URL 0xFFF4 (url)]:::box
  end

  subgraph R[Firmware Runtime]
    S[state_manager.c (scenes, brightness)]:::hi
    J[gesture_sensor.c]:::box
    P[pid_control.c (PWM target)]:::box
    L[led_driver.c (Ring scenes)]:::box
    X[ssd1306.c (Info Cap)]:::box
    A2[audio_driver.c (I2S→MAX98357A)]:::box
    Q[safety_manager.c (thermal/batt)]:::hi
  end

  subgraph Sns[Sensors / Monitors]
    M1[IMU ICM-42670]:::box
    M2[NTC Thermistor]:::box
    M3[Battery ADC]:::box
    M4[Qi2 IRQ (GPIO10)]:::box
  end

  subgraph O[Outputs]
    O1[Halo LED Ring (WS2812B)]:::out
    O2[Ceiling Projection (PWM LED)]:::out
    O3[Audio Tones (I2S 44.1k)]:::out
    O4[OLED Info Cap (SSD1306)]:::out
  end

  A -->|set scene| C1
  A -->|set brightness| C2
  A -->|set time| C3
  A --> C4
  A --> C5
  B --> J --> S
  C1 --> S
  C2 --> S
  C3 --> X
  C5 -. safety gate .-> Q

  S -->|halo id| L
  S -->|brightness target| P
  S -->|scene tone| A2
  S -->|glyph/time (mode)| X

  M1 -->|tilt proxy| P
  M2 -->|°C| Q
  M3 -->|Vbat| Q
  M4 -->|charge state| Q

  L --> O1
  P --> O2
  X --> O4
  A2 --> O3

  Q -->|derate/cutoff| O2
  Q -->|alert (red)| O1


## Runtime Flow
> Visual map from app input to firmware handlers and hardware outputs.

![scene flow](docs/img/scene_flow.svg)

<details><summary>Inline (fallback Mermaid)</summary>

```mermaid
<!-- paste docs/scene_flow.mmd here if you want inline rendering -->

</details>
```
---

Quick commit list

docs/
├─ scene_flow.dot
├─ scene_flow.mmd
└─ img/
   └─ (run the dot commands to place scene_flow.svg / .png here)

Want me to also output a Makefile target (make diagram) so anyone cloning the repo can generate the SVG in one command?





---

License

Copyright (c) 2025 Christopher Perry.
All rights reserved. Unauthorized copying of this project, via any medium, is strictly prohibited.

---
#Imagining 
---

🌌 HaloBeam™ — Scene & Projection Catalog (v1.0)

Inventor: Christopher Perry
Firmware: DFOP-Lite v1.2
Status: Patent Pending


---

📑 Scene Index

ID	Name	Icon	Purpose

0	Warm Wake	🌅	Gentle sunrise alarm
1	Focus Cool	❄️	Productivity boost
2	Sleep Amber	🛌	Bedtime wind-down
3	Aurora Flow	🌈	Immersive relaxation
4	Starry Night	🌟	Night sky simulation
5	Glyphs Info	⏱	Clock & data projection



---

🌅 Warm Wake

<details>
<summary>Click to expand</summary>User Experience
Natural sunrise glow that gradually brightens to wake the body.
<img width="1024" height="1024" alt="1000022079" src="https://github.com/user-attachments/assets/9ebf8de8-eb8f-4d0e-a06b-da01edcf0043" />

Technical

Projection: Expanding amber → orange gradient

Halo: Amber pulse synced to brightness ramp

Mode ID: SCENE_WARM_WAKE


Render Prompt → "Ceiling projection of a sunrise glow, soft amber expanding to orange. Warm halo ring glow in sync."

![1000022009](https://github.com/user-attachments/assets/87bf6238-636c-43b7-bf09-1943d4aaed8b)

SCENE_WARM_WAKE — Creative + Tech Brief

Goal (UX): a natural sunrise that gently wakes the body.
Mode ID: SCENE_WARM_WAKE
Look: soft, expanding amber→orange ceiling glow + warm halo ring that pulses with the ramp.

Color + Light (authoritative)

Projection gradient (ceiling): #FFB154 (0%) → #FF8A2A (45%) → #FF6A00 (90%) → transparent (100%)

Halo ring base (CCT): ~2200K (candlelight) ≈ #FFB154

Peak luminance targets (render): ceiling 180–220 nits center falloff to 10 nits; halo 120 nits peak (brief pulse)

Bloom/softness: Gaussian 18–24 px (1080p reference), vignette −10%


Motion / Timing (for animation or a sequence)

Ramp: 0 → 100% over 90 s

Ease: sigmoid (S-curve) f(t)=1/(1+e^(−6*(t−0.6))) on normalized time t∈[0,1]


Halo pulse: 4-second gentle pulse riding the ramp (±12% intensity), phase-locked to ramp derivative (fastest near mid-ramp)


LED Ring mapping (36 px)

Color: same as projection center (#FFB154 → #FF8A2A)

Pattern: slow “breathing” radial—every 6th pixel 10% brighter; global intensity follows ramp.



---


---
Alt text (README): For the Design tema
“Ceiling sunrise projection with soft amber-to-orange glow; HaloBeam’s warm ring pulsing gently in sync.”


---

README Snippet (drop in)

### Realistic Scene — Warm Wake (SCENE_WARM_WAKE)
Natural sunrise that gradually brightens to wake the body.

<img width="832" height="1248" alt="1000022010" src="https://github.com/user-attachments/assets/4f946132-0a37-48e7-8ba6-672162c7a250" />

**Projection:** expanding amber → orange gradient.  
**Halo:** 2200K amber pulse synchronized to brightness ramp.  
**Timing:** 0→100% over 90 s (sigmoid ease).  
**Palette:** `#FFB154 → #FF8A2A → #FF6A00`.


---

(Optional) Animation Storyboard (if you want a short loop/GIF)

Frames @ 24 fps, 6-second preview (sped-up):

Time (s)	Ramp (%)	Halo Pulse Offset	Notes

0.0	5	0.0	small amber spot, low halo
1.5	25	+0.25	radius grows, feathering increases
3.0	55	+0.50	brightest growth, halo pulse noticeable
4.5	78	+0.75	smooth falloff, ceiling fills frame
6.0	100	+1.00	stable, gentle breathing continues


</details>
---

❄️ Focus Cool

<details>
<summary>Click to expand</summary>User Experience
A crisp white-blue wash to sharpen focus.

Technical

Projection: White-blue circle, steady intensity

Halo: Static cool-white glow

Mode ID: SCENE_FOCUS_COOL


Render Prompt → "Ceiling projection of a clean white-blue pool of light, steady and sharp. Halo ring shines cool white."

<img width="1024" height="1536" alt="1000022066" src="https://github.com/user-attachments/assets/94f424e3-03fd-40c5-b8c3-6ddf1cb5afe5" />



### Scene — Focus Cool (SCENE_FOCUS_COOL)
Crisp white-blue projection designed to sharpen focus and boost concentration.

<p align="center">
  <img src="docs/img/scenes/focus_cool/halobeam_focuscool_hero_v01.png" width="980" alt="Ceiling projection with a crisp white-blue glow; HaloBeam ring glowing cool-white static">
</p>

**Projection:** static white-blue circle.  
**Halo:** steady cool-white (5000K).  
**Timing:** instant on, no pulse.  
**Palette:** `#D6F0FF → #99D4FF → #4DA6FF`.
<img width="1536" height="1024" alt="1000022083" src="https://github.com/user-attachments/assets/edb7a6b9-220d-4e21-b636-26c990b4e788" />

![1000022084](https://github.com/user-attachments/assets/de8f0de3-9d60-4861-b13a-13f467b3ab71)


</details>
---

🛌 Sleep Amber

<details>
<summary>Click to expand</summary>User Experience
Soft candle-like amber for bedtime.
  
<img width="1024" height="1024" alt="1000022082" src="https://github.com/user-attachments/assets/af9e91b5-fdbe-44e1-8ccf-4858213fcd34" />
  
<img width="1024" height="1024" alt="1000022079" src="https://github.com/user-attachments/assets/1992d74f-c01b-4804-97f5-0f8825cd803d" />

Technical

Projection: Low-intensity amber wash

Halo: Dim amber pulse

Mode ID: SCENE_SLEEP_AMBER


Render Prompt → "Ceiling projection of soft amber diffused light. Halo ring glows faint amber like a candle."

</details>
---

🌈 Aurora Flow

<details>
<summary>Click to expand</summary>User Experience
Northern-lights style flowing ribbons.
  
<img width="1536" height="1024" alt="1000022086" src="https://github.com/user-attachments/assets/1776cf4e-fdfa-4b08-b48d-cc749a9415cb" />
Technical

Projection: Green/purple/blue wave gradients

Halo: Aurora gradient cycle sync

Mode ID: SCENE_AURORA


Render Prompt → "Ceiling projection of aurora borealis with drifting ribbons of green, blue, and purple. Halo ring glows in matching gradient."

![1000022088](https://github.com/user-attachments/assets/cfc4caf3-0786-4a1d-8908-3be41ede572a)

<img width="1536" height="1024" alt="1000022087" src="https://github.com/user-attachments/assets/8b9c29a3-9ed7-4044-b2ef-dd397e71a4a0" />

</details>
---

🌟 Starry Night

<details>
<summary>Click to expand</summary>User Experience
Relax under a night sky filled with twinkling stars.
  
![1000022086](https://github.com/user-attachments/assets/9892c4e4-4621-4c42-a181-1f9cfbfc0cba)



Technical

Projection: Random white/blue star twinkles

Halo: White-blue pulse synced to stars

Mode ID: SCENE_STARRY


Render Prompt → "Ceiling projection of a starfield with twinkling white and blue points against indigo sky. Subtle halo glow in sync."

![1000022111](https://github.com/user-attachments/assets/ca0f92fb-5f84-4b43-b3b7-13ac793016b0)

</details>
---

⏱ Glyphs / Info Mode

<details>
<summary>Click to expand</summary>User Experience
Crisp clock and status icons projected on ceiling.

Technical

Projection: OLED-style time + icons (Wi-Fi, alarm, battery)

Halo: Warm amber glow for readability

Mode ID: SCENE_GLYPH
<img width="1024" height="1536" alt="1000022112" src="https://github.com/user-attachments/assets/5148a77f-f934-4e54-92fe-b8029e5134d8" />


Render Prompt → "Ceiling projection of white digital clock (12:34) with small status icons. Warm amber halo glow."

</details>
---

🔀 Combo Presets

Combo Name	Projection + Halo Pair

✨ Starry Immersion	Starry Night + Starry Halo
🌈 Aurora Immersion	Aurora Flow + Aurora Halo
📖 Amber Clock	Glyphs Info + Sleep Amber
🌅 Dawn Rise	Warm Wake + Halo sync



---
#Wiring Diagram and code 
![1000022007](https://github.com/user-attachments/assets/8521da4c-fe70-4e91-bf05-8a93775a5941)

---
// HaloBeam™ Wiring — Rev-B (ESP32-S3)
// Render: dot -Tsvg docs/wiring/halobeam_revB.dot -o docs/img/halobeam_wiring_revB.svg

digraph HaloBeam_RevB {
  rankdir=LR;
  splines=ortho;
  pad="0.2";
  nodesep="0.35"; ranksep="0.45";
  fontname="Inter, Helvetica, Arial, sans-serif";
  node [shape=box, style="rounded,filled", fontname="Inter, Helvetica, Arial, sans-serif",
        color="#D0D4D9", fillcolor="white", fontsize=11];
  edge [fontname="Inter, Helvetica, Arial, sans-serif", fontsize=10, arrowsize=0.7, color="#6B7280"];

  // === Color helpers ===
  // Nets
  color5v   = "#4F9EDD";
  color3v3  = "#78C6A3";
  colorGND  = "#B7B7B7";
  colorI2C  = "#7E6BEF";
  colorI2S  = "#FF8A5B";
  colorPWM  = "#E6B422";
  colorIRQ  = "#F05D5E";

  // === Global nets as diamonds ===
  V5   [label="5V BUS", shape=diamond, fillcolor="#E9F3FC", color=color5v];
  V3V3 [label="3V3", shape=diamond, fillcolor="#EAF7F0", color=color3v3];
  GND  [label="GND\n(Star @ Entry)", shape=diamond, fillcolor="#F3F4F6", color=colorGND];

  // === CLUSTERS ===
  // Power Entry
  subgraph cluster_power {
    label="Power Entry / Conditioning";
    color="#E5E7EB";
    PSU   [label="USB-C PSU\n24 W (cert)"];
    TVS   [label="TVS @ 5V\n(USB-C input)", shape=component];
    BuckLED [label="Bulk Cap\n1000 µF near LED ring", shape=note, fillcolor="#FFF9E8"];
    Ferrite [label="Ferrite Beads\nSpeaker/Qi harness", shape=note, fillcolor="#FFF9E8"];
  }

  // MCU
  subgraph cluster_mcu {
    label="MCU — ESP32-S3 (Rev-B pinout)";
    color="#E5E7EB";
    ESP [label=<
      <b>ESP32-S3 Module</b><br ALIGN="LEFT"/>
      GPIO18 — WS2812 DATA (RMT)<br ALIGN="LEFT"/>
      GPIO4  — Projector PWM (LEDC ch0)<br ALIGN="LEFT"/>
      GPIO5  — Servo (opt.)<br ALIGN="LEFT"/>
      GPIO8/9 — I²C SDA/SCL (IMU/OLED)<br ALIGN="LEFT"/>
      GPIO10 — Qi2 IRQ (in)<br ALIGN="LEFT"/>
      GPIO11 — Qi2 EN (out)<br ALIGN="LEFT"/>
      GPIO0 — Crown Button (pull-up)<br ALIGN="LEFT"/>
      ADC1 CH1/CH2 — VBAT / NTC<br ALIGN="LEFT"/>
      I²S BCLK/WS/SD — 15/16/17
    >, shape=box, margin="0.15,0.12"];
  }

  // Projection
  subgraph cluster_projection {
    label="Projection";
    color="#E5E7EB";
    LEDDrv [label="Projector LED Driver\n(DIM/PWM @ GPIO4)"];
    Emitter [label="Projection Emitter\n(2–5 W LED)"];
  }

  // Audio
  subgraph cluster_audio {
    label="Audio";
    color="#E5E7EB";
    AMP [label="MAX98357A\n(I²S DAC/AMP)"];
    SPK [label="2× 40 mm + Radiator", shape=ellipse];
  }

  // Charging
  subgraph cluster_qi2 {
    label="Qi2 Wireless Charging";
    color="#E5E7EB";
    PMIC [label="Qi2 PMIC + Coil Module"];
  }

  // Sensors & Inputs
  subgraph cluster_sensors {
    label="Sensors & Inputs";
    color="#E5E7EB";
    IMU   [label="ICM-42670\n(I²C @ 0x68)"];
    OLED  [label="OLED SSD1306\n(Info Cap, I²C @ 0x3C)"];
    NTC   [label="NTC 10k/3950\n→ ADC1 CH2 (GPIO3)"];
    VBAT  [label="VBAT Divider\n→ ADC1 CH1 (GPIO2)"];
    BTN   [label="Crown Button\n(GPIO0, pull-up)"];
    RING  [label="WS2812B Ring\n36 px (RMT @ GPIO18)", shape=ellipse, fillcolor="#F5FAFF"];
  }

  // === Power rails ===
  PSU  -> V5  [color=color5v, penwidth=2];
  PSU  -> GND [color=colorGND, arrowsize=0.6];
  V5   -> TVS [color=color5v];
  V5   -> BuckLED [color=color5v, style=dashed];
  Ferrite -> GND [color=colorGND, arrowsize=0.6, style=dashed];

  // === Power distribution ===
  V5 -> AMP   [color=color5v];   AMP   -> GND [color=colorGND, arrowsize=0.6];
  V5 -> RING  [color=color5v];   RING  -> GND [color=colorGND, arrowsize=0.6];
  V5 -> LEDDrv[color=color5v];   LEDDrv-> GND [color=colorGND, arrowsize=0.6];
  V5 -> PMIC  [color=color5v];   PMIC  -> GND [color=colorGND, arrowsize=0.6];

  // === 3V3 logic rail (if present from ESP module) ===
  V3V3 -> IMU  [color=color3v3];
  V3V3 -> OLED [color=color3v3];

  // === Signals ===
  // I²C
  ESP -> IMU  [label="SDA/SCL", color=colorI2C];
  ESP -> OLED [label="SDA/SCL", color=colorI2C];

  // I²S
  ESP -> AMP  [label="I²S BCLK/WS/SD\n15/16/17", color=colorI2S];

  // PWM to projector
  ESP -> LEDDrv [label="PWM (GPIO4)", color=colorPWM];
  LEDDrv -> Emitter [label="LED", color="#9CA3AF"];

  // LED ring (RMT)
  ESP -> RING [label="DATA (GPIO18)", color="#3B82F6"];

  // ADCs
  VBAT -> ESP [label="ADC1 CH1", color="#54B397"];
  NTC  -> ESP [label="ADC1 CH2", color="#54B397"];

  // Inputs
  BTN -> ESP  [label="GPIO0", color="#9CA3AF"];

  // Qi2 control/IRQ
  ESP -> PMIC [label="EN (GPIO11)", color=colorPWM, style=dashed];
  PMIC -> ESP [label="IRQ (GPIO10)", color=colorIRQ];

  // Grounds
  IMU  -> GND [color=colorGND, arrowsize=0.6];
  OLED -> GND [color=colorGND, arrowsize=0.6];
  BTN  -> GND [color=colorGND, arrowsize=0.6];
  LEDDrv -> GND [color=colorGND, arrowsize=0.6];
  Emitter -> GND [color=colorGND, arrowsize=0.6];
  RING -> GND [color=colorGND, arrowsize=0.6];

  // Layout hints
  {rank=same; V5; V3V3; GND}
  {rank=same; PSU; TVS}
  {rank=same; IMU; OLED; NTC; VBAT; BTN; RING}
}
---
